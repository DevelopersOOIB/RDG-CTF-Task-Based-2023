# Adware Hater


## Описание
Что может быть хуже реверса адвары? Правильно, реверс азиатской адвары ...

## WriteUp

Реверс приложений на свифте начинается с гугла основных классов, они еще подсвечиваются в иде жирным шрифтом.

Отсюда узнаем, что в первую очередь на интересуют **ViewController** и **AppDelegate**, где первый отвечает за интерфейс, а второй - за все, что происходит под капотом у приложения.

Основная полезная нагрузка обычно расположена в селекторе **applicationDidFinishLaunching** класса **AppDelegate**, этот кейс не исключение.

Сразу видим, что есть зашифрованные строки. 
Переходим в реализацию расшифровывающего метода, понимаем, что это обычная подстановка и зашифрованные строки представляют собой смещения относительно начала массива байт ключа.

Сам ключ находим в инициализаторе класса, который реализует дешифрование.

Когда разобрались со строками, можно приступать к анализу семпла.

Важно не пропустить инициализацию объектов кастомных классов в начале, чтобы не упустить вызовы их селекторов (а видно их достаточно плохо на фоне того мусора, что нагенерил свифт).

Вызовы в декомпилированном коде выглядят следующим образом:

```
    (*(*class_obj + some_int))
    (some_var)
```

Для того, чтобы понять, что же вызывается, на структуру этого класса в секции **__data**.<br>
После того, как разобрались и подписали все необходимое, реверс становится вполне простым. 

Видим, что сначала собираются данные о компьютере путем выполнения **Shell** команд и кладутся в словарь, затем они проверяются.

Затем производится отправка данных на несуществующий **CNC**. Перед отправкой **POST** запроса создается структура **randomStruct**, в которой предопределяются дефолтные данные.

Самое сложное - понять, как в нее записываются данные.<br> 
Так как хексрейс беспомощен перед святым свифтом, нужно просто посмотреть в дизассемблер и убедиться в том, что в **RAX** перед вызовом **randomStruct.init** кладется адрес, в который затем записываются данные.

В одном из полей структуры нам дается подсказка, что где-то должен быть **DES** ключ, а в последнем - лежит **8-байтовый** ключ.

Немного проследив далее видим, что эта структура должна перезаписаться данными с сервера, а затем оттуда берется значение последнего поля **(farquaadsLittleKey)**. 
По возвращении в **AppDelegate** можем заметить, что из возвращенного ключа берутся два последних байта и присоединяются к строке **01da94**. 
Полученное значение передается на последний этап - селектор **becomeAHero**. 
Тут просто инициализируется флаг, передается на вход классу с реализованным **DES** дешифратором, и затем флаг принтится.

Вы спросите, а где же ключ, если последние два его байта должны быть получены с несуществующего сервера? Ответ вас убьёт - **их надо забрутить)**


 

